(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~BattleTech~index"],{

/***/ "afol":
/*!******************************************************************!*\
  !*** ./node_modules/bcdice/lib/bcdice/game_system/BattleTech.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./../opal */ "pQ1d");
/* Generated by Opal 1.1.1 */


Opal.modules["bcdice/dice_table/table"] = function (Opal) {
  function $rb_minus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $hash2 = Opal.hash2,
      $truthy = Opal.truthy;
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'DiceTable');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Table');
        var $nesting = [self].concat($parent_nesting),
            $Table_from_i18n$1,
            $Table_initialize$2,
            $Table_roll$3,
            $Table_choice$4;
        self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
        Opal.defs(self, '$from_i18n', $Table_from_i18n$1 = function $$from_i18n(key, locale) {
          var self = this,
              table = nil;
          table = $$($nesting, 'I18n').$t(key, $hash2(["locale"], {
            "locale": locale
          }));
          return self.$new(table['$[]']("name"), table['$[]']("type"), table['$[]']("items"));
        }, $Table_from_i18n$1.$$arity = 2);
        Opal.def(self, '$initialize', $Table_initialize$2 = function $$initialize(name, type, items) {
          var self = this,
              m = nil;
          self.name = name;
          self.items = items.$freeze();
          m = /(\d+)D(\d+)/i.$match(type);

          if ($truthy(m)) {} else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + type);
          }

          ;
          self.times = m['$[]'](1).$to_i();
          return self.sides = m['$[]'](2).$to_i();
        }, $Table_initialize$2.$$arity = 3);
        Opal.def(self, '$roll', $Table_roll$3 = function $$roll(bcdice) {
          var self = this,
              value = nil;
          value = bcdice.$roll_sum(self.times, self.sides);
          return self.$choice(value);
        }, $Table_roll$3.$$arity = 1);
        return (Opal.def(self, '$choice', $Table_choice$4 = function $$choice(value) {
          var self = this,
              index = nil;
          index = $rb_minus(value, self.times);
          return $$($nesting, 'RollResult').$new(self.name, value, self.items['$[]'](index));
        }, $Table_choice$4.$$arity = 1), nil) && 'choice';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
};
/* Generated by Opal 1.1.1 */


Opal.modules["bcdice/dice_table/range_table"] = function (Opal) {
  function $rb_minus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
  }

  function $rb_times(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
  }

  function $rb_plus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $send = Opal.send,
      $truthy = Opal.truthy;
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'DiceTable');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RangeTable');

        var $nesting = [self].concat($parent_nesting),
            _$RangeTable$,
            $RangeTable_initialize$3,
            $RangeTable_fetch$4,
            $RangeTable_roll$6,
            $RangeTable_store$7,
            $RangeTable_coerce_to_int_range$11,
            $RangeTable_assert_min_sum_is_covered$12,
            $RangeTable_assert_max_sum_is_covered$13,
            $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

        self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
        Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], (_$RangeTable$ = function $RangeTable$1() {
          var self = _$RangeTable$.$$s == null ? this : _$RangeTable$.$$s;
          return self.$alias_method("to_s", "formatted");
        }, _$RangeTable$.$$s = self, _$RangeTable$.$$arity = 0, _$RangeTable$)));
        Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
        Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
        Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($$2 = function (_$$) {
          function $$2(_x, _x2) {
            return _$$.apply(this, arguments);
          }

          $$2.toString = function () {
            return _$$.toString();
          };

          return $$2;
        }(function (table, result) {
          var self = $$2.$$s == null ? this : $$2.$$s;

          if (table == null) {
            table = nil;
          }

          ;

          if (result == null) {
            result = nil;
          }

          ;
          return "" + table.$name() + "(" + result.$sum() + ") ＞ " + result.$content();
        }), $$2.$$s = self, $$2.$$arity = 2, $$2)));
        self.$attr_reader("name");
        self.$attr_reader("num_of_dice");
        self.$attr_reader("num_of_sides");
        Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
          var $iter = $RangeTable_initialize$3.$$p,
              formatter = $iter || nil,
              self = this,
              $ret_or_1 = nil,
              m = nil;
          if ($iter) $RangeTable_initialize$3.$$p = null;
          if ($iter) $RangeTable_initialize$3.$$p = null;
          ;
          self.name = name.$freeze();

          self.formatter = function () {
            if ($truthy($ret_or_1 = formatter)) {
              return $ret_or_1;
            } else {
              return $$($nesting, 'DEFAULT_FORMATTER');
            }

            ;
            return nil;
          }();

          m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);

          if ($truthy(m)) {} else {
            self.$raise($$($nesting, 'ArgumentError'), "" + self.name + ": invalid dice roll method: " + dice_roll_method);
          }

          ;
          self.num_of_dice = m['$[]'](1).$to_i();
          self.num_of_sides = m['$[]'](2).$to_i();
          return self.$store(items);
        }, $RangeTable_initialize$3.$$arity = 3);
        Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
          var _$$2,
              self = this,
              item = nil;

          item = $send(self.items, 'find', [], (_$$2 = function $$5(i) {
            var self = _$$2.$$s == null ? this : _$$2.$$s;

            if (i == null) {
              i = nil;
            }

            ;
            return i.$range()['$include?'](value);
          }, _$$2.$$s = self, _$$2.$$arity = 1, _$$2));

          if ($truthy(item)) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": value is out of range: " + value);
          }

          ;
          return item;
        }, $RangeTable_fetch$4.$$arity = 1);
        Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(randomizer) {
          var self = this,
              values = nil,
              sum = nil,
              result = nil,
              $writer = nil;
          values = randomizer.$roll_barabara(self.num_of_dice, self.num_of_sides);
          sum = values.$sum();
          result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
          $writer = [self.formatter['$[]'](self, result)];
          $send(result, 'formatted=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
          ;
          return result;
        }, $RangeTable_roll$6.$$arity = 1);
        self.$private();
        Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
          var _$$3,
              _$$4,
              _$$5,
              self = this,
              items_with_range = nil,
              sorted_items = nil;

          items_with_range = $send(items, 'map', [], (_$$3 = function $$8(r, c) {
            var self = _$$3.$$s == null ? this : _$$3.$$s;

            if (r == null) {
              r = nil;
            }

            ;

            if (c == null) {
              c = nil;
            }

            ;
            return [self.$coerce_to_int_range(r), c];
          }, _$$3.$$s = self, _$$3.$$arity = 2, _$$3));
          sorted_items = $send(items_with_range, 'sort_by', [], (_$$4 = function $$9(r, _) {
            var self = _$$4.$$s == null ? this : _$$4.$$s;

            if (r == null) {
              r = nil;
            }

            ;

            if (_ == null) {
              _ = nil;
            }

            ;
            return r.$min();
          }, _$$4.$$s = self, _$$4.$$arity = 2, _$$4));
          self.$assert_min_sum_is_covered(sorted_items);
          self.$assert_max_sum_is_covered(sorted_items);
          self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
          self.items = $send(sorted_items, 'map', [], (_$$5 = function $$10(range, content) {
            var self = _$$5.$$s == null ? this : _$$5.$$s;

            if (range == null) {
              range = nil;
            }

            ;

            if (content == null) {
              content = nil;
            }

            ;
            return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();
          }, _$$5.$$s = self, _$$5.$$arity = 2, _$$5)).$freeze();
          return self;
        }, $RangeTable_store$7.$$arity = 1);
        Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
          var self = this,
              $case = nil,
              $ret_or_2 = nil;
          $case = x;

          if ($$($nesting, 'Integer')['$===']($case)) {
            return $$($nesting, 'Range').$new(x, x);
          } else if ($$($nesting, 'Range')['$===']($case)) {
            if ($truthy(function () {
              if ($truthy($ret_or_2 = x.$begin()['$is_a?']($$($nesting, 'Integer')))) {
                return x.$end()['$is_a?']($$($nesting, 'Integer'));
              } else {
                return $ret_or_2;
              }

              ;
              return nil;
            }())) {
              return x;
            }
          }

          ;
          return self.$raise($$($nesting, 'TypeError'), "" + self.name + ": " + x + " (" + x.$class() + ") must be an Integer or a Range with Integers ");
        }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
        Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
          var self = this,
              min_sum = nil,
              range = nil;
          min_sum = self.num_of_dice;
          range = sorted_items.$first()['$[]'](0);

          if ($truthy(range['$include?'](min_sum))) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": min value (" + min_sum + ") is not covered: " + range);
          }

          ;
          return self;
        }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
        Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
          var self = this,
              max_sum = nil,
              range = nil;
          max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
          range = sorted_items.$last()['$[]'](0);

          if ($truthy(range['$include?'](max_sum))) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": max value (" + max_sum + ") is not covered: " + range);
          }

          ;
          return self;
        }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
        return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
          var _$$6,
              self = this;

          $send(sorted_items, 'each_cons', [2], (_$$6 = function $$15(i1, i2) {
            var self = _$$6.$$s == null ? this : _$$6.$$s,
                r1 = nil,
                r2 = nil,
                max1 = nil,
                next_of_max1 = nil;
            if (self.name == null) self.name = nil;

            if (i1 == null) {
              i1 = nil;
            }

            ;

            if (i2 == null) {
              i2 = nil;
            }

            ;
            r1 = i1['$[]'](0);
            r2 = i2['$[]'](0);
            max1 = r1.$max();
            next_of_max1 = $rb_plus(max1, 1);

            if ($truthy(r2['$include?'](max1))) {
              self.$raise($$($nesting, 'RangeError'), "" + self.name + ": Range overlap: " + r1 + " and " + r2);
            }

            ;

            if ($truthy(r2['$include?'](next_of_max1))) {
              return nil;
            } else {
              return self.$raise($$($nesting, 'RangeError'), "" + self.name + ": Range gap: " + r1 + " and " + r2);
            }

            ;
          }, _$$6.$$s = self, _$$6.$$arity = 2, _$$6));
          return self;
        }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
};
/* Generated by Opal 1.1.1 */


(function (Opal) {
  function $rb_times(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
  }

  function $rb_plus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
  }

  function $rb_gt(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs > rhs : lhs['$>'](rhs);
  }

  function $rb_ge(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs >= rhs : lhs['$>='](rhs);
  }

  function $rb_divide(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
  }

  function $rb_minus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $truthy = Opal.truthy,
      $send = Opal.send,
      $hash2 = Opal.hash2,
      $range = Opal.range;
  self.$require("bcdice/dice_table/table");
  self.$require("bcdice/dice_table/range_table");
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'GameSystem');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BattleTech');
        var $nesting = [self].concat($parent_nesting),
            $BattleTech_eval_game_system_specific_command$1,
            $BattleTech_getXrmDamage$4,
            $BattleTech_getHitResult$5,
            $BattleTech_getBaseValue$7,
            $BattleTech_getHitText$8,
            $BattleTech_getDamages$9,
            $BattleTech_getDamageInfo$11,
            $BattleTech_getTotalDamage$12,
            $BattleTech_getHitResultOne$15,
            $BattleTech_getCheckDieResult$16;
        self.$$prototype.randomizer = nil;
        Opal.const_set($nesting[0], 'ID', "BattleTech");
        Opal.const_set($nesting[0], 'NAME', "バトルテック");
        Opal.const_set($nesting[0], 'SORT_KEY', "はとるてつく");
        Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・判定方法\n" + "　(回数)BT(ダメージ)(部位)+(基本値)>=(目標値)\n" + "　回数は省略時 1固定。\n" + "　部位はC（正面）R（右）、L（左）。省略時はC（正面）固定\n" + "　U（上半身）、L（下半身）を組み合わせ CU/RU/LU/CL/RL/LLも指定可能\n" + "　例）BT3+2>=4\n" + "　　正面からダメージ3の攻撃を技能ベース2目標値4で1回判定\n" + "　例）2BT3RL+5>=8\n" + "　　右下半身にダメージ3の攻撃を技能ベース5目標値8で2回判定\n" + "　ミサイルによるダメージは BT(ダメージ)の変わりに SRM2/4/6, LRM5/10/15/20を指定\n" + "　例）3SRM6LU+5>=8\n" + "　　左上半身にSRM6連を技能ベース5目標値8で3回判定\n" + "・CT：致命的命中表\n" + "・DW：転倒後の向き表\n" + "・CDx：メック戦士意識維持表。ダメージ値xで判定　例）CD3\n");
        self.$register_prefix("\\d*SRM", "\\d*LRM", "\\d*BT", "PPC", "CT", "DW", "CD");
        Opal.const_set($nesting[0], 'NO_CRITICAL_HIT_LIMIT', 7);
        Opal.def(self, '$eval_game_system_specific_command', $BattleTech_eval_game_system_specific_command$1 = function $$eval_game_system_specific_command(command) {
          var self = this,
              result = nil,
              count = nil,
              $case = nil,
              damage = nil,
              tail = nil,
              type = nil,
              damageFunc = nil,
              damageValue = nil;

          try {
            result = self.$roll_tables(command, $$($nesting, 'TABLES'));

            if ($truthy(result)) {
              return result;
            }

            ;
            command = command.$gsub("PPC", "BT10");
            count = 1;

            if ($truthy(command['$=~'](/^(\d+)(.+)/))) {
              count = $$($nesting, 'Regexp').$last_match(1).$to_i();
              command = $$($nesting, 'Regexp').$last_match(2);
            }

            ;
            self.$debug("executeCommandCatched count", count);
            self.$debug("executeCommandCatched command", command);
            $case = command;

            if (/^CD(\d+)$/['$===']($case)) {
              damage = $$($nesting, 'Regexp').$last_match(1).$to_i();
              return self.$getCheckDieResult(damage);
            } else if (/^((S|L)RM\d+)(.+)/['$===']($case)) {
              tail = $$($nesting, 'Regexp').$last_match(3);
              type = $$($nesting, 'Regexp').$last_match(1);
              damageFunc = $send(self, 'lambda', [], ($$2 = function (_$$7) {
                function $$2() {
                  return _$$7.apply(this, arguments);
                }

                $$2.toString = function () {
                  return _$$7.toString();
                };

                return $$2;
              }(function () {
                var self = $$2.$$s == null ? this : $$2.$$s;
                return self.$getXrmDamage(type);
              }), $$2.$$s = self, $$2.$$arity = 0, $$2));
              return self.$getHitResult(count, damageFunc, tail);
            } else if (/^BT(\d+)(.+)/['$===']($case)) {
              self.$debug("BT pattern");
              tail = $$($nesting, 'Regexp').$last_match(2);
              damageValue = $$($nesting, 'Regexp').$last_match(1).$to_i();
              damageFunc = $send(self, 'lambda', [], ($$3 = function (_$$8) {
                function $$3() {
                  return _$$8.apply(this, arguments);
                }

                $$3.toString = function () {
                  return _$$8.toString();
                };

                return $$3;
              }(function () {
                var self = $$3.$$s == null ? this : $$3.$$s;
                return damageValue;
              }), $$3.$$s = self, $$3.$$arity = 0, $$3));
              return self.$getHitResult(count, damageFunc, tail);
            }

            ;
            return nil;
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'UnknownXRMError')])) {
              try {
                return nil;
              } finally {
                Opal.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        }, $BattleTech_eval_game_system_specific_command$1.$$arity = 1);

        (function ($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'UnknownXRMError');
          var $nesting = [self].concat($parent_nesting);
          return nil;
        })($nesting[0], $$($nesting, 'StandardError'), $nesting);

        Opal.def(self, '$getXrmDamage', $BattleTech_getXrmDamage$4 = function $$getXrmDamage(type) {
          var self = this,
              table = nil,
              roll_result = nil,
              lrm = nil,
              damage = nil,
              modified_damage = nil;

          if ($truthy($$($nesting, 'XRM_DAMAGE_TABLES')['$key?'](type))) {} else {
            self.$raise($$($nesting, 'UnknownXRMError'), "" + "unknown XRM: " + type);
          }

          ;
          table = $$($nesting, 'XRM_DAMAGE_TABLES')['$[]'](type);
          roll_result = table.$roll(self.randomizer);
          lrm = type['$start_with?']("L");
          damage = roll_result.$content();

          modified_damage = function () {
            if ($truthy(lrm)) {
              return damage;
            } else {
              return $rb_times(2, damage);
            }

            ;
            return nil;
          }();

          return [modified_damage, roll_result.$sum(), lrm];
        }, $BattleTech_getXrmDamage$4.$$arity = 1);
        Opal.const_set($nesting[0], 'LRM_LIMIT', 5);
        Opal.def(self, '$getHitResult', $BattleTech_getHitResult$5 = function $$getHitResult(count, damageFunc, tail) {
          var _$$9,
              self = this,
              m = nil,
              side = nil,
              $ret_or_1 = nil,
              baseString = nil,
              target = nil,
              base = nil,
              partTable = nil,
              resultTexts = nil,
              damages = nil,
              hitCount = nil,
              totalResultText = nil;

          m = /([LCR][LU]?)?(\+\d+)?>=(\d+)/.$match(tail);

          if ($truthy(m)) {} else {
            return nil;
          }

          ;

          side = function () {
            if ($truthy($ret_or_1 = m['$[]'](1))) {
              return $ret_or_1;
            } else {
              return "C";
            }

            ;
            return nil;
          }();

          baseString = m['$[]'](2);
          target = m['$[]'](3).$to_i();
          base = self.$getBaseValue(baseString);
          self.$debug("side, base, target", side, base, target);
          partTable = $$$($$($nesting, 'HitPart'), 'TABLES')['$[]'](side);
          resultTexts = [];
          damages = $hash2([], {});
          hitCount = 0;
          $send(count, 'times', [], (_$$9 = function $$6() {
            var self = _$$9.$$s == null ? this : _$$9.$$s,
                $a,
                $b,
                isHit = nil,
                hitResult = nil,
                damageText = nil;
            $b = self.$getHitText(base, target), $a = Opal.to_ary($b), isHit = $a[0] == null ? nil : $a[0], hitResult = $a[1] == null ? nil : $a[1], $b;

            if ($truthy(isHit)) {
              hitCount = $rb_plus(hitCount, 1);
              $b = self.$getDamages(damageFunc, partTable, damages), $a = Opal.to_ary($b), damages = $a[0] == null ? nil : $a[0], damageText = $a[1] == null ? nil : $a[1], $b;
              hitResult = $rb_plus(hitResult, damageText);
            }

            ;
            return resultTexts['$<<'](hitResult);
          }, _$$9.$$s = self, _$$9.$$arity = 0, _$$9));
          resultTexts.$push("" + " ＞ " + hitCount + "回命中");
          totalResultText = resultTexts.$join("\n");

          if ($truthy($rb_gt(hitCount, 0))) {
            totalResultText = $rb_plus(totalResultText, $rb_plus(" 命中箇所：", self.$getTotalDamage(damages)));
          }

          ;
          return totalResultText;
        }, $BattleTech_getHitResult$5.$$arity = 3);
        Opal.def(self, '$getBaseValue', $BattleTech_getBaseValue$7 = function $$getBaseValue(baseString) {
          var self = this,
              base = nil;
          base = 0;

          if ($truthy(baseString['$nil?']())) {
            return base;
          }

          ;
          base = $$($nesting, 'ArithmeticEvaluator').$eval(baseString);
          return base;
        }, $BattleTech_getBaseValue$7.$$arity = 1);
        Opal.def(self, '$getHitText', $BattleTech_getHitText$8 = function $$getHitText(base, target) {
          var self = this,
              dice1 = nil,
              dice2 = nil,
              total = nil,
              isHit = nil,
              baseString = nil,
              result = nil;
          dice1 = self.randomizer.$roll_once(6);
          dice2 = self.randomizer.$roll_once(6);
          total = $rb_plus($rb_plus(dice1, dice2), base);
          isHit = $rb_ge(total, target);

          baseString = function () {
            if ($truthy($rb_gt(base, 0))) {
              return "" + "+" + base;
            } else {
              return "";
            }

            ;
            return nil;
          }();

          result = "" + total + "[" + dice1 + "," + dice2 + baseString + "]>=" + target + " ＞ ";

          if ($truthy(isHit)) {
            result = $rb_plus(result, "命中 ＞ ");
          } else {
            result = $rb_plus(result, "外れ");
          }

          ;
          return [isHit, result];
        }, $BattleTech_getHitText$8.$$arity = 2);
        Opal.def(self, '$getDamages', $BattleTech_getDamages$9 = function $$getDamages(damageFunc, partTable, damages) {
          var $a,
              $b,
              _$$10,
              self = this,
              resultText = nil,
              damage = nil,
              dice = nil,
              isLrm = nil,
              damagePartCount = nil;

          resultText = "";
          $b = damageFunc.$call(), $a = Opal.to_ary($b), damage = $a[0] == null ? nil : $a[0], dice = $a[1] == null ? nil : $a[1], isLrm = $a[2] == null ? nil : $a[2], $b;
          damagePartCount = 1;

          if ($truthy(isLrm)) {
            damagePartCount = $rb_divide($rb_times(1.0, damage), $$($nesting, 'LRM_LIMIT')).$ceil();
            resultText = $rb_plus(resultText, "" + "[" + dice + "] " + damage + "点");
          }

          ;
          $send(damagePartCount, 'times', [], (_$$10 = function $$10(damageIndex) {
            var self = _$$10.$$s == null ? this : _$$10.$$s,
                $c,
                $d,
                currentDamage = nil,
                damageText = nil,
                text = nil,
                part = nil,
                criticalText = nil,
                $writer = nil;

            if (damageIndex == null) {
              damageIndex = nil;
            }

            ;
            $d = self.$getDamageInfo(dice, damage, isLrm, damageIndex), $c = Opal.to_ary($d), currentDamage = $c[0] == null ? nil : $c[0], damageText = $c[1] == null ? nil : $c[1], $d;
            $d = self.$getHitResultOne(damageText, partTable), $c = Opal.to_ary($d), text = $c[0] == null ? nil : $c[0], part = $c[1] == null ? nil : $c[1], criticalText = $c[2] == null ? nil : $c[2], $d;

            if ($truthy(isLrm)) {
              resultText = $rb_plus(resultText, " ");
            }

            ;
            resultText = $rb_plus(resultText, text);

            if ($truthy(damages['$[]'](part)['$nil?']())) {
              $writer = [part, $hash2(["partDamages", "criticals"], {
                "partDamages": [],
                "criticals": []
              })];
              $send(damages, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }

            ;
            damages['$[]'](part)['$[]']("partDamages")['$<<'](currentDamage);

            if ($truthy(criticalText['$empty?']())) {
              return nil;
            } else {
              return damages['$[]'](part)['$[]']("criticals")['$<<'](criticalText);
            }

            ;
          }, _$$10.$$s = self, _$$10.$$arity = 1, _$$10));
          return [damages, resultText];
        }, $BattleTech_getDamages$9.$$arity = 3);
        Opal.def(self, '$getDamageInfo', $BattleTech_getDamageInfo$11 = function $$getDamageInfo(dice, damage, isLrm, index) {
          var self = this,
              currentDamage = nil;

          if ($truthy(dice['$nil?']())) {
            return [damage, damage.$to_s()];
          }

          ;

          if ($truthy(isLrm)) {} else {
            return [damage, "" + "[" + dice + "] " + damage];
          }

          ;
          currentDamage = $rb_minus(damage, $rb_times($$($nesting, 'LRM_LIMIT'), index));

          if ($truthy($rb_gt(currentDamage, $$($nesting, 'LRM_LIMIT')))) {
            currentDamage = $$($nesting, 'LRM_LIMIT');
          }

          ;
          return [currentDamage, currentDamage.$to_s()];
        }, $BattleTech_getDamageInfo$11.$$arity = 4);
        Opal.def(self, '$getTotalDamage', $BattleTech_getTotalDamage$12 = function $$getTotalDamage(damages) {
          var _$$12,
              self = this,
              parts = nil,
              allDamage = nil,
              damageTexts = nil,
              result = nil;

          parts = ["頭", "胴中央", "右胴", "左胴", "右脚", "左脚", "右腕", "左腕"];
          allDamage = 0;
          damageTexts = [];
          $send(parts, 'each', [], (_$$12 = function $$13(part) {
            var self = _$$12.$$s == null ? this : _$$12.$$s,
                _$$11,
                damageInfo = nil,
                damage = nil,
                damageCount = nil,
                criticals = nil,
                text = nil;

            if (part == null) {
              part = nil;
            }

            ;
            damageInfo = damages.$delete(part);

            if ($truthy(damageInfo['$nil?']())) {
              return nil;
            }

            ;
            damage = $send(damageInfo['$[]']("partDamages"), 'inject', [0], (_$$11 = function $$14(sum, i) {
              var self = _$$11.$$s == null ? this : _$$11.$$s;

              if (sum == null) {
                sum = nil;
              }

              ;

              if (i == null) {
                i = nil;
              }

              ;
              return $rb_plus(sum, i);
            }, _$$11.$$s = self, _$$11.$$arity = 2, _$$11));
            allDamage = $rb_plus(allDamage, damage);
            damageCount = damageInfo['$[]']("partDamages").$size();
            criticals = damageInfo['$[]']("criticals");
            text = "";
            text = $rb_plus(text, "" + part + "(" + damageCount + "回) " + damage + "点");

            if ($truthy(criticals['$empty?']())) {} else {
              text = $rb_plus(text, "" + " " + criticals.$join(" "));
            }

            ;
            return damageTexts['$<<'](text);
          }, _$$12.$$s = self, _$$12.$$arity = 1, _$$12));

          if ($truthy(damages['$empty?']())) {} else {
            self.$raise("" + "damages rest!! " + damages.$inspect());
          }

          ;
          result = damageTexts.$join(" ／ ");
          result = $rb_plus(result, "" + " ＞ 合計ダメージ " + allDamage + "点");
          return result;
        }, $BattleTech_getTotalDamage$12.$$arity = 1);
        Opal.def(self, '$getHitResultOne', $BattleTech_getHitResultOne$15 = function $$getHitResultOne(damage_text, hit_part_table) {
          var self = this,
              hit_part_roll_result = nil,
              hit_part = nil,
              critical_hit_may_occur_str = nil,
              result_parts = nil,
              criticalText = nil,
              ct_roll_result = nil;
          hit_part_roll_result = hit_part_table.$roll(self.randomizer);
          hit_part = hit_part_roll_result.$content();

          critical_hit_may_occur_str = function () {
            if ($truthy(hit_part.$critical_hit_may_occur())) {
              return "（致命的命中）";
            } else {
              return "";
            }

            ;
            return nil;
          }();

          result_parts = [["" + "[" + hit_part_roll_result.$sum() + "]", "" + hit_part.$name() + critical_hit_may_occur_str, "" + damage_text + "点"].$join(" ")];
          criticalText = "";

          if ($truthy(hit_part.$critical_hit_may_occur())) {
            ct_roll_result = $$($nesting, 'TABLES')['$[]']("CT").$roll(self.randomizer);

            if ($truthy($rb_gt(ct_roll_result.$sum(), $$($nesting, 'NO_CRITICAL_HIT_LIMIT')))) {
              criticalText = ct_roll_result.$content();
            }

            ;
            result_parts.$push("" + "[" + ct_roll_result.$sum() + "] " + ct_roll_result.$content());
          }

          ;
          return [result_parts.$join(" ＞ "), hit_part.$name(), criticalText];
        }, $BattleTech_getHitResultOne$15.$$arity = 2);
        Opal.def(self, '$getCheckDieResult', $BattleTech_getCheckDieResult$16 = function $$getCheckDieResult(damage) {
          var self = this,
              table = nil,
              target = nil,
              dice1 = nil,
              dice2 = nil,
              total = nil,
              result = nil,
              text = nil;

          if ($truthy($rb_ge(damage, 6))) {
            return "死亡";
          }

          ;
          table = [[1, 3], [2, 5], [3, 7], [4, 10], [5, 11]];
          target = self.$get_table_by_number(damage, table, nil);
          dice1 = self.randomizer.$roll_once(6);
          dice2 = self.randomizer.$roll_once(6);
          total = $rb_plus(dice1, dice2);

          result = function () {
            if ($truthy($rb_ge(total, target))) {
              return "成功";
            } else {
              return "失敗";
            }

            ;
            return nil;
          }();

          text = "" + total + "[" + dice1 + "," + dice2 + "]>=" + target + " ＞ " + result;
          return text;
        }, $BattleTech_getCheckDieResult$16.$$arity = 1);
        Opal.const_set($nesting[0], 'TABLES', $hash2(["CT", "DW"], {
          "CT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("致命的命中表", "2D6", [[Opal.Range.$new(2, $$($nesting, 'NO_CRITICAL_HIT_LIMIT'), false), "致命的命中はなかった"], [$range(8, 9, false), "1箇所の致命的命中"], [$range(10, 11, false), "2箇所の致命的命中"], [12, "その部位が吹き飛ぶ（腕、脚、頭）または3箇所の致命的命中（胴）"]]),
          "DW": $$$($$($nesting, 'DiceTable'), 'Table').$new("転倒後の向き表", "1D6", ["同じ（前面から転倒） 正面／背面", "1ヘクスサイド右（側面から転倒） 右側面", "2ヘクスサイド右（側面から転倒） 右側面", "180度逆（背面から転倒） 正面／背面", "2ヘクスサイド左（側面から転倒） 左側面", "1ヘクスサイド左（側面から転倒） 左側面"])
        }).$freeze());
        Opal.const_set($nesting[0], 'HitPart', $$($nesting, 'Struct').$new("name", "critical_hit_may_occur"));

        (function ($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'HitPart');
          var $nesting = [self].concat($parent_nesting);
          Opal.const_set($nesting[0], 'LEFT_TORSO', "左胴");
          Opal.const_set($nesting[0], 'CENTER_TORSO', "胴中央");
          Opal.const_set($nesting[0], 'RIGHT_TORSO', "右胴");
          Opal.const_set($nesting[0], 'LEFT_ARM', "左腕");
          Opal.const_set($nesting[0], 'RIGHT_ARM', "右腕");
          Opal.const_set($nesting[0], 'LEFT_LEG', "左脚");
          Opal.const_set($nesting[0], 'RIGHT_LEG', "右脚");
          Opal.const_set($nesting[0], 'HEAD', "頭");
          return Opal.const_set($nesting[0], 'TABLES', $hash2(["L", "C", "R", "LU", "CU", "RU", "LL", "CL", "RL"], {
            "L": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（左）", "2D6", [[2, self.$new($$($nesting, 'LEFT_TORSO'), true)], [3, self.$new($$($nesting, 'LEFT_LEG'), false)], [$range(4, 5, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [6, self.$new($$($nesting, 'LEFT_LEG'), false)], [7, self.$new($$($nesting, 'LEFT_TORSO'), false)], [8, self.$new($$($nesting, 'CENTER_TORSO'), false)], [9, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [10, self.$new($$($nesting, 'RIGHT_ARM'), false)], [11, self.$new($$($nesting, 'RIGHT_LEG'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]),
            "C": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（正面）", "2D6", [[2, self.$new($$($nesting, 'CENTER_TORSO'), true)], [$range(3, 4, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [5, self.$new($$($nesting, 'RIGHT_LEG'), false)], [6, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [7, self.$new($$($nesting, 'CENTER_TORSO'), false)], [8, self.$new($$($nesting, 'LEFT_TORSO'), false)], [9, self.$new($$($nesting, 'LEFT_LEG'), false)], [$range(10, 11, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]),
            "R": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（右）", "2D6", [[2, self.$new($$($nesting, 'RIGHT_TORSO'), true)], [3, self.$new($$($nesting, 'RIGHT_LEG'), false)], [$range(4, 5, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'RIGHT_LEG'), false)], [7, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [8, self.$new($$($nesting, 'CENTER_TORSO'), false)], [9, self.$new($$($nesting, 'LEFT_TORSO'), false)], [10, self.$new($$($nesting, 'LEFT_ARM'), false)], [11, self.$new($$($nesting, 'LEFT_LEG'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]),
            "LU": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（左上半身）", "1D6", [[$range(1, 2, false), self.$new($$($nesting, 'LEFT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [$range(4, 5, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]),
            "CU": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（正面上半身）", "1D6", [[1, self.$new($$($nesting, 'LEFT_ARM'), false)], [2, self.$new($$($nesting, 'LEFT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [4, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [5, self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]),
            "RU": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（右上半身）", "1D6", [[$range(1, 2, false), self.$new($$($nesting, 'RIGHT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [$range(4, 5, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]),
            "LL": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（左下半身）", "1D6", [[$range(1, 6, false), self.$new($$($nesting, 'LEFT_LEG'), false)]]),
            "CL": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（右下半身）", "1D6", [[$range(1, 3, false), self.$new($$($nesting, 'RIGHT_LEG'), false)], [$range(4, 6, false), self.$new($$($nesting, 'LEFT_LEG'), false)]]),
            "RL": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("命中部位表（右下半身）", "1D6", [[$range(1, 6, false), self.$new($$($nesting, 'RIGHT_LEG'), false)]])
          }).$freeze());
        })($nesting[0], null, $nesting);

        return Opal.const_set($nesting[0], 'XRM_DAMAGE_TABLES', $hash2(["SRM2", "SRM4", "SRM6", "LRM5", "LRM10", "LRM15", "LRM20"], {
          "SRM2": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("SRM2ダメージ表", "2D6", [[$range(2, 7, false), 1], [$range(8, 12, false), 2]]),
          "SRM4": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("SRM4ダメージ表", "2D6", [[2, 1], [$range(3, 6, false), 2], [$range(7, 10, false), 3], [$range(11, 12, false), 4]]),
          "SRM6": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("SRM6ダメージ表", "2D6", [[$range(2, 3, false), 2], [$range(4, 5, false), 3], [$range(6, 8, false), 4], [$range(9, 10, false), 5], [$range(11, 12, false), 6]]),
          "LRM5": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("LRM5ダメージ表", "2D6", [[2, 1], [$range(3, 4, false), 2], [$range(5, 8, false), 3], [$range(9, 10, false), 4], [$range(11, 12, false), 5]]),
          "LRM10": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("LRM10ダメージ表", "2D6", [[$range(2, 3, false), 3], [4, 4], [$range(5, 8, false), 6], [$range(9, 10, false), 8], [$range(11, 12, false), 10]]),
          "LRM15": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("LRM15ダメージ表", "2D6", [[$range(2, 3, false), 5], [4, 6], [$range(5, 8, false), 9], [$range(9, 10, false), 12], [$range(11, 12, false), 15]]),
          "LRM20": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("LRM20ダメージ表", "2D6", [[$range(2, 3, false), 6], [4, 9], [$range(5, 8, false), 12], [$range(9, 10, false), 16], [$range(11, 12, false), 20]])
        }).$freeze());
      })($nesting[0], $$($nesting, 'Base'), $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
})(Opal);

/***/ })

}]);
//# sourceMappingURL=default~BattleTech~index.js.map