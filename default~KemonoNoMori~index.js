(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~KemonoNoMori~index"],{

/***/ "7yUK":
/*!********************************************************************!*\
  !*** ./node_modules/bcdice/lib/bcdice/game_system/KemonoNoMori.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./../opal */ "pQ1d");
/* Generated by Opal 1.1.1 */


Opal.modules["bcdice/dice_table/table"] = function (Opal) {
  function $rb_minus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $hash2 = Opal.hash2,
      $truthy = Opal.truthy;
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'DiceTable');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Table');
        var $nesting = [self].concat($parent_nesting),
            $Table_from_i18n$1,
            $Table_initialize$2,
            $Table_roll$3,
            $Table_choice$4;
        self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
        Opal.defs(self, '$from_i18n', $Table_from_i18n$1 = function $$from_i18n(key, locale) {
          var self = this,
              table = nil;
          table = $$($nesting, 'I18n').$t(key, $hash2(["locale"], {
            "locale": locale
          }));
          return self.$new(table['$[]']("name"), table['$[]']("type"), table['$[]']("items"));
        }, $Table_from_i18n$1.$$arity = 2);
        Opal.def(self, '$initialize', $Table_initialize$2 = function $$initialize(name, type, items) {
          var self = this,
              m = nil;
          self.name = name;
          self.items = items.$freeze();
          m = /(\d+)D(\d+)/i.$match(type);

          if ($truthy(m)) {} else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + type);
          }

          ;
          self.times = m['$[]'](1).$to_i();
          return self.sides = m['$[]'](2).$to_i();
        }, $Table_initialize$2.$$arity = 3);
        Opal.def(self, '$roll', $Table_roll$3 = function $$roll(bcdice) {
          var self = this,
              value = nil;
          value = bcdice.$roll_sum(self.times, self.sides);
          return self.$choice(value);
        }, $Table_roll$3.$$arity = 1);
        return (Opal.def(self, '$choice', $Table_choice$4 = function $$choice(value) {
          var self = this,
              index = nil;
          index = $rb_minus(value, self.times);
          return $$($nesting, 'RollResult').$new(self.name, value, self.items['$[]'](index));
        }, $Table_choice$4.$$arity = 1), nil) && 'choice';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
};
/* Generated by Opal 1.1.1 */


Opal.modules["bcdice/dice_table/range_table"] = function (Opal) {
  function $rb_minus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs - rhs : lhs['$-'](rhs);
  }

  function $rb_times(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs * rhs : lhs['$*'](rhs);
  }

  function $rb_plus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $send = Opal.send,
      $truthy = Opal.truthy;
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'DiceTable');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RangeTable');

        var $nesting = [self].concat($parent_nesting),
            _$RangeTable$,
            $RangeTable_initialize$3,
            $RangeTable_fetch$4,
            $RangeTable_roll$6,
            $RangeTable_store$7,
            $RangeTable_coerce_to_int_range$11,
            $RangeTable_assert_min_sum_is_covered$12,
            $RangeTable_assert_max_sum_is_covered$13,
            $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

        self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
        Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], (_$RangeTable$ = function $RangeTable$1() {
          var self = _$RangeTable$.$$s == null ? this : _$RangeTable$.$$s;
          return self.$alias_method("to_s", "formatted");
        }, _$RangeTable$.$$s = self, _$RangeTable$.$$arity = 0, _$RangeTable$)));
        Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
        Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
        Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($$2 = function (_$$) {
          function $$2(_x, _x2) {
            return _$$.apply(this, arguments);
          }

          $$2.toString = function () {
            return _$$.toString();
          };

          return $$2;
        }(function (table, result) {
          var self = $$2.$$s == null ? this : $$2.$$s;

          if (table == null) {
            table = nil;
          }

          ;

          if (result == null) {
            result = nil;
          }

          ;
          return "" + table.$name() + "(" + result.$sum() + ") ＞ " + result.$content();
        }), $$2.$$s = self, $$2.$$arity = 2, $$2)));
        self.$attr_reader("name");
        self.$attr_reader("num_of_dice");
        self.$attr_reader("num_of_sides");
        Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
          var $iter = $RangeTable_initialize$3.$$p,
              formatter = $iter || nil,
              self = this,
              $ret_or_1 = nil,
              m = nil;
          if ($iter) $RangeTable_initialize$3.$$p = null;
          if ($iter) $RangeTable_initialize$3.$$p = null;
          ;
          self.name = name.$freeze();

          self.formatter = function () {
            if ($truthy($ret_or_1 = formatter)) {
              return $ret_or_1;
            } else {
              return $$($nesting, 'DEFAULT_FORMATTER');
            }

            ;
            return nil;
          }();

          m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);

          if ($truthy(m)) {} else {
            self.$raise($$($nesting, 'ArgumentError'), "" + self.name + ": invalid dice roll method: " + dice_roll_method);
          }

          ;
          self.num_of_dice = m['$[]'](1).$to_i();
          self.num_of_sides = m['$[]'](2).$to_i();
          return self.$store(items);
        }, $RangeTable_initialize$3.$$arity = 3);
        Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
          var _$$2,
              self = this,
              item = nil;

          item = $send(self.items, 'find', [], (_$$2 = function $$5(i) {
            var self = _$$2.$$s == null ? this : _$$2.$$s;

            if (i == null) {
              i = nil;
            }

            ;
            return i.$range()['$include?'](value);
          }, _$$2.$$s = self, _$$2.$$arity = 1, _$$2));

          if ($truthy(item)) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": value is out of range: " + value);
          }

          ;
          return item;
        }, $RangeTable_fetch$4.$$arity = 1);
        Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(randomizer) {
          var self = this,
              values = nil,
              sum = nil,
              result = nil,
              $writer = nil;
          values = randomizer.$roll_barabara(self.num_of_dice, self.num_of_sides);
          sum = values.$sum();
          result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
          $writer = [self.formatter['$[]'](self, result)];
          $send(result, 'formatted=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
          ;
          return result;
        }, $RangeTable_roll$6.$$arity = 1);
        self.$private();
        Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
          var _$$3,
              _$$4,
              _$$5,
              self = this,
              items_with_range = nil,
              sorted_items = nil;

          items_with_range = $send(items, 'map', [], (_$$3 = function $$8(r, c) {
            var self = _$$3.$$s == null ? this : _$$3.$$s;

            if (r == null) {
              r = nil;
            }

            ;

            if (c == null) {
              c = nil;
            }

            ;
            return [self.$coerce_to_int_range(r), c];
          }, _$$3.$$s = self, _$$3.$$arity = 2, _$$3));
          sorted_items = $send(items_with_range, 'sort_by', [], (_$$4 = function $$9(r, _) {
            var self = _$$4.$$s == null ? this : _$$4.$$s;

            if (r == null) {
              r = nil;
            }

            ;

            if (_ == null) {
              _ = nil;
            }

            ;
            return r.$min();
          }, _$$4.$$s = self, _$$4.$$arity = 2, _$$4));
          self.$assert_min_sum_is_covered(sorted_items);
          self.$assert_max_sum_is_covered(sorted_items);
          self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
          self.items = $send(sorted_items, 'map', [], (_$$5 = function $$10(range, content) {
            var self = _$$5.$$s == null ? this : _$$5.$$s;

            if (range == null) {
              range = nil;
            }

            ;

            if (content == null) {
              content = nil;
            }

            ;
            return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();
          }, _$$5.$$s = self, _$$5.$$arity = 2, _$$5)).$freeze();
          return self;
        }, $RangeTable_store$7.$$arity = 1);
        Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
          var self = this,
              $case = nil,
              $ret_or_2 = nil;
          $case = x;

          if ($$($nesting, 'Integer')['$===']($case)) {
            return $$($nesting, 'Range').$new(x, x);
          } else if ($$($nesting, 'Range')['$===']($case)) {
            if ($truthy(function () {
              if ($truthy($ret_or_2 = x.$begin()['$is_a?']($$($nesting, 'Integer')))) {
                return x.$end()['$is_a?']($$($nesting, 'Integer'));
              } else {
                return $ret_or_2;
              }

              ;
              return nil;
            }())) {
              return x;
            }
          }

          ;
          return self.$raise($$($nesting, 'TypeError'), "" + self.name + ": " + x + " (" + x.$class() + ") must be an Integer or a Range with Integers ");
        }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
        Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
          var self = this,
              min_sum = nil,
              range = nil;
          min_sum = self.num_of_dice;
          range = sorted_items.$first()['$[]'](0);

          if ($truthy(range['$include?'](min_sum))) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": min value (" + min_sum + ") is not covered: " + range);
          }

          ;
          return self;
        }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
        Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
          var self = this,
              max_sum = nil,
              range = nil;
          max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
          range = sorted_items.$last()['$[]'](0);

          if ($truthy(range['$include?'](max_sum))) {} else {
            self.$raise($$($nesting, 'RangeError'), "" + self.name + ": max value (" + max_sum + ") is not covered: " + range);
          }

          ;
          return self;
        }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
        return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
          var _$$6,
              self = this;

          $send(sorted_items, 'each_cons', [2], (_$$6 = function $$15(i1, i2) {
            var self = _$$6.$$s == null ? this : _$$6.$$s,
                r1 = nil,
                r2 = nil,
                max1 = nil,
                next_of_max1 = nil;
            if (self.name == null) self.name = nil;

            if (i1 == null) {
              i1 = nil;
            }

            ;

            if (i2 == null) {
              i2 = nil;
            }

            ;
            r1 = i1['$[]'](0);
            r2 = i2['$[]'](0);
            max1 = r1.$max();
            next_of_max1 = $rb_plus(max1, 1);

            if ($truthy(r2['$include?'](max1))) {
              self.$raise($$($nesting, 'RangeError'), "" + self.name + ": Range overlap: " + r1 + " and " + r2);
            }

            ;

            if ($truthy(r2['$include?'](next_of_max1))) {
              return nil;
            } else {
              return self.$raise($$($nesting, 'RangeError'), "" + self.name + ": Range gap: " + r1 + " and " + r2);
            }

            ;
          }, _$$6.$$s = self, _$$6.$$arity = 2, _$$6));
          return self;
        }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
};
/* Generated by Opal 1.1.1 */


(function (Opal) {
  function $rb_plus(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs + rhs : lhs['$+'](rhs);
  }

  function $rb_divide(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs / rhs : lhs['$/'](rhs);
  }

  function $rb_le(lhs, rhs) {
    return typeof lhs === 'number' && typeof rhs === 'number' ? lhs <= rhs : lhs['$<='](rhs);
  }

  var self = Opal.top,
      $nesting = [],
      nil = Opal.nil,
      $$$ = Opal.$$$,
      $$ = Opal.$$,
      $module = Opal.module,
      $klass = Opal.klass,
      $truthy = Opal.truthy,
      $hash2 = Opal.hash2,
      $range = Opal.range;
  self.$require("bcdice/dice_table/table");
  self.$require("bcdice/dice_table/range_table");
  return function ($base, $parent_nesting) {
    var self = $module($base, 'BCDice');
    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, 'GameSystem');
      var $nesting = [self].concat($parent_nesting);

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'KemonoNoMori');
        var $nesting = [self].concat($parent_nesting),
            $KemonoNoMori_eval_game_system_specific_command$1,
            $KemonoNoMori_check_1D12$2,
            $KemonoNoMori_getTrapResult$3,
            $KemonoNoMori_getEscapeExperienceTableResult$4;
        self.$$prototype.randomizer = nil;
        Opal.const_set($nesting[0], 'ID', "KemonoNoMori");
        Opal.const_set($nesting[0], 'NAME', "獸ノ森");
        Opal.const_set($nesting[0], 'SORT_KEY', "けもののもり");
        Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・行為判定(成功度自動算出): KAx[±y]\n" + "・継続判定(成功度+1固定): KCx[±y]\n" + "   x=目標値\n" + "   y=目標値への修正(任意) x+y-z のように複数指定可能\n" + "     例1）KA7+3 → 目標値7にプラス3の修正を加えた行為判定\n" + "     例2）KC6 → 目標値6の継続判定\n" + "・罠動作判定: CTR\n" + "   罠ごとに1D12を振る。12が出た場合は罠が動作し、獲物がその効果を受ける\n" + "・各種表\n" + "  ・大失敗表: FT\n" + "  ・能力値ランダム決定表: RST\n" + "  ・ランダム所要時間表: RTT\n" + "  ・ランダム消耗表: RET\n" + "  ・ランダム天気表: RWT\n" + "  ・ランダム天気持続表: RWDT\n" + "  ・ランダム遮蔽物表（屋外）: ROMT\n" + "  ・ランダム遮蔽物表（屋内）: RIMT\n" + "  ・逃走体験表: EET\n" + "  ・食材採集表: GFT\n" + "  ・水採集表: GWT\n" + "  ・白の魔石効果表: WST\n");
        Opal.def(self, '$eval_game_system_specific_command', $KemonoNoMori_eval_game_system_specific_command$1 = function $$eval_game_system_specific_command(command) {
          var self = this,
              $case = nil;
          return function () {
            $case = command;

            if (/KA\d[-+\d]*/['$===']($case)) {
              return self.$check_1D12(command, true);
            } else if (/KC\d[-+\d]*/['$===']($case)) {
              return self.$check_1D12(command, false);
            } else if ("CTR"['$===']($case)) {
              return self.$getTrapResult();
            } else if ("EET"['$===']($case)) {
              return self.$getEscapeExperienceTableResult(command);
            } else {
              return self.$roll_tables(command, $$($nesting, 'TABLES'));
            }
          }();
        }, $KemonoNoMori_eval_game_system_specific_command$1.$$arity = 1);
        Opal.def(self, '$check_1D12', $KemonoNoMori_check_1D12$2 = function $$check_1D12(command, is_action_judge) {
          var self = this,
              m = nil,
              target_total = nil,
              success_degree = nil,
              dice_total = nil;
          self.$debug("獸ノ森の1d12判定");
          m = /K[AC](\d[-+\d]*)/.$match(command);

          if ($truthy(m)) {} else {
            return "";
          }

          ;
          target_total = $$($nesting, 'ArithmeticEvaluator').$eval(m['$[]'](1));
          self.$debug("target_total", target_total);

          success_degree = function () {
            if ($truthy(is_action_judge)) {
              return $rb_plus($rb_divide(target_total, 10).$to_i(), 1);
            } else {
              return 1;
            }

            ;
            return nil;
          }();

          dice_total = self.randomizer.$roll_once(12);
          self.$debug("dice_total, target_total, success_degree = ", dice_total, target_total, success_degree);

          if (dice_total['$=='](12)) {
            return "" + "(1D12<=" + target_total + ") ＞ " + dice_total + " ＞ 大失敗";
          } else if (dice_total['$=='](11)) {
            return "" + "(1D12<=" + target_total + ") ＞ " + dice_total + " ＞ 大成功（成功度+" + success_degree + ", 次の継続判定の目標値を10に変更）";
          } else if ($truthy($rb_le(dice_total, target_total))) {
            return "" + "(1D12<=" + target_total + ") ＞ " + dice_total + " ＞ 成功（成功度+" + success_degree + "）";
          } else {
            return "" + "(1D12<=" + target_total + ") ＞ " + dice_total + " ＞ 失敗";
          }

          ;
        }, $KemonoNoMori_check_1D12$2.$$arity = 2);
        Opal.def(self, '$getTrapResult', $KemonoNoMori_getTrapResult$3 = function $$getTrapResult() {
          var self = this,
              trapCheckNumber = nil,
              chaseNumber = nil,
              chase = nil,
              $case = nil;
          trapCheckNumber = self.randomizer.$roll_once(12);

          if (trapCheckNumber['$=='](12)) {
            chaseNumber = self.randomizer.$roll_once(12);
            chase = nil;
            $case = chaseNumber;

            if (1['$===']($case) || 2['$===']($case) || 3['$===']($case) || 4['$===']($case)) {
              chase = "小型動物";
            } else if (5['$===']($case) || 6['$===']($case) || 7['$===']($case) || 8['$===']($case)) {
              chase = "大型動物";
            } else if (9['$===']($case) || 10['$===']($case) || 11['$===']($case) || 12['$===']($case)) {
              chase = "人間の放浪者";
            }

            ;
            return "" + "罠動作チェック(1D12) ＞ " + trapCheckNumber + " ＞ 罠が動作していた！ ＞ 獲物表(" + chaseNumber + ") ＞ " + chase + "が罠にかかっていた";
          }

          ;
          return "" + "罠動作チェック(1D12) ＞ " + trapCheckNumber + " ＞ 罠は動作していなかった";
        }, $KemonoNoMori_getTrapResult$3.$$arity = 0);
        Opal.def(self, '$getEscapeExperienceTableResult', $KemonoNoMori_getEscapeExperienceTableResult$4 = function $$getEscapeExperienceTableResult(command) {
          var self = this,
              escapeExperience = nil,
              escapeDuration = nil;
          escapeExperience = self.$roll_tables(command, $$($nesting, 'TABLES'));
          escapeDuration = self.randomizer.$roll_once(12);
          return "" + escapeExperience + " (再登場: " + escapeDuration + "時間後)";
        }, $KemonoNoMori_getEscapeExperienceTableResult$4.$$arity = 1);
        Opal.const_set($nesting[0], 'TABLES', $hash2(["FT", "RST", "RTT", "RET", "RWT", "RWDT", "ROMT", "RIMT", "EET", "GFT", "GWT", "WST"], {
          "FT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("大失敗表", "1D12", [[$range(1, 3, false), "【余裕】が3点減少する（最低0まで）"], [$range(4, 5, false), "ランダムな荷物1個が落ちて行方不明になる（大失敗したエリアのアイテム調査で見つけることが可能）"], [$range(6, 7, false), "ランダムな荷物1個が破壊される"], [$range(8, 9, false), "ランダム天気表を使用し、結果をターンの終了まで適用する"], [10, "ランダムな準備している小道具1個が破壊される"], [11, "着想している防具が破壊される"], [12, "準備している武器が破壊される"]]),
          "RST": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("能力値ランダム決定表", "1D12", [[$range(1, 2, false), "【移動】"], [$range(3, 4, false), "【格闘】"], [$range(5, 6, false), "【射撃】"], [$range(7, 8, false), "【製作】"], [$range(9, 10, false), "【察知】"], [$range(11, 12, false), "【自制】"]]),
          "RTT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム所要時間表", "1D12", [[$range(1, 3, false), "2"], [$range(4, 6, false), "3"], [$range(7, 9, false), "4"], [$range(10, 12, false), "5"]]),
          "RET": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム消耗表", "1D12", [[$range(1, 3, false), "0"], [$range(4, 6, false), "1"], [$range(7, 9, false), "2"], [$range(10, 12, false), "4"]]),
          "RWT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム天気表", "1D12", [[$range(1, 2, false), "濃霧"], [$range(3, 4, false), "大雨"], [$range(5, 6, false), "雷雨"], [$range(7, 8, false), "強風"], [$range(9, 10, false), "酷暑"], [$range(11, 12, false), "極寒"]]),
          "RWDT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム天気持続表", "1D12", [[$range(1, 2, false), "1ターン"], [$range(3, 4, false), "3ターン"], [$range(5, 6, false), "6ターン"], [$range(7, 8, false), "24ターン"], [$range(9, 10, false), "72ターン"], [$range(11, 12, false), "156ターン"]]),
          "ROMT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム遮蔽物表(屋外)", "1D12", [[$range(1, 2, false), "【藪】耐久度3,軽減値1,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(3, 5, false), "【木】耐久度5,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(6, 8, false), "【大木】耐久度7,軽減値3,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-2の修正を付加"], [$range(9, 10, false), "【岩】耐久度6,軽減値4,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加/コンタクト内で行われる格闘攻撃のダメージ+1"], [$range(11, 12, false), "【岩壁】耐久度8,軽減値4,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-2の修正を付加/コンタクト内で行われる格闘攻撃のダメージ+2"]]),
          "RIMT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("ランダム遮蔽物表(屋内)", "1D12", [[$range(1, 4, false), "【木材の壁】耐久度4,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(5, 8, false), "【木材の扉】耐久度4,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1、接触判定と突撃判定に-2の修正を付加"], [$range(9, 12, false), "【木製家具】耐久度3,軽減値2,特殊効果:コンタクト内で行われる格闘攻撃のダメージ+1"]]),
          "EET": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("逃走体験表", "1D12", [[$range(1, 3, false), "【余裕】が0になる"], [$range(4, 6, false), "任意の【絆】を合計2点減少する"], [$range(7, 9, false), "全ての荷物を失う（逃走したエリアに配置され、調査で発見可能）"], [$range(10, 12, false), "全ての武器と防具と小道具と荷物を失う（逃走したエリアに配置され、調査で発見可能）"]]),
          "GFT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("食材採集表", "1D12", [[$range(1, 2, false), "食べられる根（栄養価:2）"], [$range(3, 5, false), "食べられる草（栄養価:3）"], [$range(6, 8, false), "食べられる実（栄養価:5）"], [$range(9, 10, false), "小型動物（栄養価:10）"], [11, "大型動物（栄養価:40）"], [12, "気持ち悪い虫（栄養価:1）"]]),
          "GWT": $$$($$($nesting, 'DiceTable'), 'RangeTable').$new("水採集表", "1D12", [[$range(1, 6, false), "汚水"], [$range(7, 11, false), "飲料水"], [12, "毒水"]]),
          "WST": $$$($$($nesting, 'DiceTable'), 'Table').$new("白の魔石効果表", "1D12", ["役に立たないものの色を変える", "役に立たないものを大きくする", "役に立たないものを小さくする", "役に立たないものを保存する", "役に立たないものを復元する", "役に立たないものを召喚する", "役に立たないものを動かす", "役に立たないものを増やす", "役に立たないものを貼り付ける", "役に立たないものを作り出す", "小型動物を召喚する", "大型動物を召喚する"])
        }).$freeze());
        return self.$register_prefix("K[AC]", "CTR", $$($nesting, 'TABLES').$keys());
      })($nesting[0], $$($nesting, 'Base'), $nesting);
    })($nesting[0], $nesting);
  }($nesting[0], $nesting);
})(Opal);

/***/ })

}]);
//# sourceMappingURL=default~KemonoNoMori~index.js.map